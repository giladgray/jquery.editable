// Generated by CoffeeScript 1.8.0

/*
jquery.editable
@author Gilad Gray <giladgray@gmail.com>
@date June 16, 2014

A simple plugin for making a piece of text editable through a backing `<input>`
field. Requires the appropriate HTML in place (see example).

There are two ways for user to start editing the text:

1. Clicking on the `editable-trigger` classed icon,

2. Clicking on the text value.

When the edit mode is entered, the text becomes hidden and input is shown.
Setting `data-clickable-to-edit` to `false` on an element will prevent entering edit mode
when that element is clicked.
Typing `enter` key or focusing away from the input will commit the edited text
(unless empty), triggering a `commit` event with the new value and copying it
the text field.

@example Example HTML with data-api:
  <div class="editable" data-toggle="editable">
    <span class="value">Palantir!</span>
    <span class="edit"><input type="text" value="Palantir"></span>
    <span class="fa fa-pencil editable-trigger"></span>
  </div>

@example Another example HTML with data-api, where `.value` field is not clickable to edit:
  <div class="editable" data-toggle="editable">
    <span class="value" data-clickable-to-edit=false>Click on the icon to start editing!</span>
    <span class="edit"><input type="text" value="Enter new text"></span>
    <span class="fa fa-pencil editable-trigger"></span>
  </div>

If an element with `editable` class has the `type-update` class as well, then
after every change of the value an `update` event will be fired. This allows
for responding to changes during typing.

@example Example HTML with data-api:
  <div class="editable" data-type-update=true data-toggle="editable">
    <span class="value">Start typing!</span>
    <span class="edit"><input type="text" value=""></span>
    <span class="fa fa-pencil editable-trigger"></span>
  </div>
 */

(function() {
  var Editable,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Editable = (function() {
    Editable.TOGGLE = '[data-toggle=editable]';

    Editable.DEFAULTS = {};

    function Editable(element, options) {
      this.cancel = __bind(this.cancel, this);
      this.commit = __bind(this.commit, this);
      this.update = __bind(this.update, this);
      this.edit = __bind(this.edit, this);
      var clickableElements, editElements;
      this.$el = $(element);
      this.$input = this.$el.find('input');
      this.$value = this.$el.find('.value');
      editElements = ['.editable-trigger', '.value'];
      clickableElements = _.filter(editElements, (function(_this) {
        return function(selector) {
          return _this.$el.find(selector).data('clickable-to-edit') !== false;
        };
      })(this));
      this.$el.on('click.editable', clickableElements.join(','), this.edit);
      this.$input.on('blur.editable', this.commit);
      this.doNotCommit = false;
      this.$input.on('mousedown', (function(_this) {
        return function() {
          return _this.doNotCommit = true;
        };
      })(this));
      this.$input.on('mouseup', (function(_this) {
        return function() {
          return _this.doNotCommit = false;
        };
      })(this));
      this.$input.on('keydown.editable', (function(_this) {
        return function(evt) {
          if (evt.which === 13) {
            return _this.$input.blur();
          } else if (evt.which === 27) {
            return _this.cancel();
          }
        };
      })(this));
      if (this.$el.attr('data-type-update')) {
        this.$input.on('keyup.editable', (function(_this) {
          return function(evt) {
            if (evt.which !== 13 && evt.which !== 27) {
              return _this.update();
            }
          };
        })(this));
      }
    }

    Editable.prototype.edit = function() {
      if (this.$el.hasClass('editing')) {
        return true;
      }
      this.lastValue = this.$input.val();
      this.$el.addClass('editing').trigger('edit');
      this.$input.val('');
      this.$input.focus().val(this.lastValue);
      if (this.lastValue) {
        this.update();
      }
      return false;
    };

    Editable.prototype.update = function() {
      return this.$el.trigger('update', this.$input.val());
    };

    Editable.prototype.commit = function() {
      var value;
      if (!(this.lastValue && !this.doNotCommit)) {
        return;
      }
      value = this.$input.val() || this.lastValue;
      if (value.length) {
        this.lastValue = null;
        this.$value.text(value);
        this.$input.val(value);
        return this.$el.removeClass('editing').trigger('commit', value);
      }
    };

    Editable.prototype.cancel = function() {
      this.$value.text(this.lastValue);
      this.$el.removeClass('editing');
      this.$input.val(this.lastValue);
      return this.lastValue = null;
    };

    return Editable;

  })();


  /*
  Initialize the Editable plugin on the selected elements.
   */

  $.fn.editable = function(option) {
    return this.each(function() {
      var $this, data, options;
      $this = $(this);
      data = $this.data('editable');
      options = typeof option === 'object' && option;
      if (!data) {
        $this.data('editable', data = new Editable(this, options));
      }
      if (typeof option === 'string') {
        return data[option]();
      }
    });
  };

  $.fn.editable.Constructor = Editable;

  $(document).on('click.editable.data-api', Editable.TOGGLE, function(e) {
    var $el;
    $el = $(e.target);
    if ($el.data('clickable-to-edit') !== false) {
      if (!$el.has(Editable.TOGGLE).length) {
        $el = $el.closest(Editable.TOGGLE);
      }
      $el.editable('edit');
      return false;
    }
    return true;
  });

}).call(this);
